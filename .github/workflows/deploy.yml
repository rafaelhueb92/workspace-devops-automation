name: Deploy Terraform to Azure

on:
  workflow_dispatch:
    inputs:
      destroy:
        description: 'Destruct?'
        required: true
        default: 'false'
        type: choice
        options:
          - "false"
          - "true"

permissions:
  id-token: write
  contents: read

env:
  ARTIFACT_NAME: "api-${{ github.sha }}.jar"
  IMAGE_NAME: "java-api:${{ github.sha }}"

jobs:
  validate:
    if: ${{ github.event.inputs.destroy == 'false' }}
    name: üîé Validate Terraform
    runs-on: ubuntu-latest
    steps:
      - name: Code Checkout
        uses: actions/checkout@v3

      - name: Login in Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Validate Sintax and Plan
        working-directory: infra
        run: |
          export ARM_SUBSCRIPTION_ID=${{ secrets.ARM_SUBSCRIPTION_ID }}
          terraform init
          terraform fmt -check
          terraform validate
          terraform plan -out=tfplan

  deploy:
    if: ${{ github.event.inputs.destroy == 'false' }}
    name: üöÄ Infra Deploy and Config
    needs: validate
    runs-on: ubuntu-latest
    outputs:
      vmName: ${{ steps.output_vm.outputs.vm_name }}
      adminUsername: ${{ steps.output_vm.outputs.admin_username }}
      publicIP: ${{ steps.output_vm.outputs.public_ip }}
      nsgName: ${{ steps.output_vm.outputs.nsg_name }}
      resourceGroup: ${{ steps.output_vm.outputs.resource_group }}
      acr_login_server: ${{ steps.output_vm.outputs.acr_login_server}}
    steps:
      - name: Code Checkout
        uses: actions/checkout@v3

      - name: Login in Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Apply Terraform
        working-directory: infra
        run: |
          export ARM_SUBSCRIPTION_ID=${{ secrets.ARM_SUBSCRIPTION_ID }}
          terraform init
          terraform apply -auto-approve 

      - name: Capture Outputs
        id: output_vm
        working-directory: infra
        run: |
          echo "vm_name=vm-automation" >> $GITHUB_OUTPUT
          echo "admin_username=azureuser" >> $GITHUB_OUTPUT
          echo "public_ip=$(terraform output -raw public_ip_address)" >> $GITHUB_OUTPUT
          echo "nsg_name=$(terraform output -raw nsg_name)" >> $GITHUB_OUTPUT
          echo "resource_group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "acr_login_server=$(terraform output -raw acr_login_server)" >> $GITHUB_OUTPUT

      - name: Define Environment Variables
        run: |
          echo "VM_NAME=vm-automation" >> $GITHUB_ENV
          echo "ADMIN_USERNAME=azureuser" >> $GITHUB_ENV
          echo "PUBLIC_IP=${{ steps.output_vm.outputs.public_ip }}" >> $GITHUB_ENV
          echo "SSH_COMMAND=ssh azureuser@${{ steps.output_vm.outputs.public_ip }}" >> $GITHUB_ENV

  acr:
    if: ${{ github.event.inputs.destroy == 'false' }}
    name: üì§ Push Image to ACR
    needs: deploy
    runs-on: ubuntu-latest
    env:
      REGISTRY_NAME: ${{ needs.deploy.outputs.acr_login_server }}
      REGISTRY_IMAGE: "${{ needs.deploy.outputs.acr_login_server }}/java-api:${{ github.sha }}"
    outputs:
      publicIP: ${{ needs.deploy.outputs.publicIP }}
      adminUsername: ${{ needs.deploy.outputs.adminUsername }}
    defaults:
      run:
        working-directory: ./app
    steps:
      - name: üîç Checkout Code
        uses: actions/checkout@v3

      - name: ‚òï Setup Java
        uses: actions/setup-java@v2
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: üì¶ Build with Maven
        run: mvn clean package -DskipTests

      - name: üß™ Run Tests
        run: mvn test

      - name: üõ† Build Docker Image
        run: docker build -t ${{ env.IMAGE_NAME }} .

      - name: üîê Trivy Scan (Image)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_NAME }}
          format: table
          exit-code: 0
          severity: HIGH,CRITICAL

      - name: üîê Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: üîê Docker Login to ACR
        run: az acr login --name ${{ env.REGISTRY_NAME }}

      - name: üè∑Ô∏è Tag Docker Image
        run: docker tag ${{ env.IMAGE_NAME }} ${{ env.REGISTRY_IMAGE }}

      - name: üì§ Push to Azure Container Registry
        run: docker push ${{ env.REGISTRY_IMAGE }}

  deploy-ansible:
   if: ${{ github.event.inputs.destroy == 'false' }}
   name: üöÄ Deploy with Ansible
   needs: acr
   runs-on: ubuntu-latest
   env:
      PUBLIC_IP: ${{ needs.acr.outputs.publicIP }}
      ADMIN_USERNAME: ${{ needs.acr.outputs.adminUsername }}
   steps:
    - name: Code Checkout
      uses: actions/checkout@v3

    - name: Install Ansible and sshpass
      run: |
        sudo apt-get update
        sudo apt-get install -y ansible sshpass

    - name: Create Ansible Inventory 
      run: |
        echo "[vm]" > inventory
        echo "${{ env.PUBLIC_IP }} ansible_user=${{ env.ADMIN_USERNAME }} ansible_password=${{ secrets.ADMIN_PASSWORD }} ansible_ssh_common_args='-o StrictHostKeyChecking=no'" >> inventory
    
    - name: Execute Ansible Playbook
      run: |
        ansible-playbook -i inventory ansible/playbook.yml --extra-vars "ansible_sudo_pass=${{ secrets.ADMIN_PASSWORD }}"

  post-tests:
    if: ${{ github.event.inputs.destroy == 'false' }}
    name: ‚úÖ Infra Post Tests
    needs: [deploy,deploy-ansible]
    runs-on: ubuntu-latest
    env:
      PUBLIC_IP: ${{ needs.deploy.outputs.publicIP }}
      VM_NAME: ${{ needs.deploy.outputs.vmName }}
      NSG_NAME: ${{ needs.deploy.outputs.nsgName }}
      RESOURCE_GROUP: ${{ needs.deploy.outputs.resourceGroup }}
    steps:
      - name: Login in Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Test Swagger on Port 8081
        run: |
          echo "Waiting app load with Swagger..."
          sleep 30
          response=$(curl -s -o /dev/null -w "%{http_code}" http://$PUBLIC_IP:8081/swagger-ui/index.html)
          if [ "$response" != "200" ]; then
            echo "‚ùå Swagger not response as expected. Status HTTP: $response"
            exit 1
          else
            echo "‚úÖ Swagger available in /swagger-ui/index.html on port 8081!"
          fi

      - name: Verify VM Status
        run: |
          status=$(az vm get-instance-view \
            --name "$VM_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --query "instanceView.statuses[?code=='PowerState/running'].displayStatus" \
            --output tsv)

          echo "VM Status : $status"

          if [ "$status" != "VM running" ]; then
              echo "‚ùå A VM n√£o est√° em execu√ß√£o!"
              exit 1
          else
              echo "‚úÖ VM is running successfully!"
          fi

      - name: Verify rule NSG for port 8081
        run: |
          result=$(az network nsg rule list \
            --nsg-name "$NSG_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --query "[?destinationPortRange=='8081' && access=='Allow']")

          if [ "$result" = "[]" ]; then
            echo "‚ùå Port 8081 isn't released NSG!"
            exit 1
          else
            echo "‚úÖ Port 8081 is available in NSG!"
          fi
      
      - name: URL Swagger to Acess
        run: echo "Access in your navigator http://$PUBLIC_IP:8081/swagger-ui/index.html"  

  destroy:
    if: ${{ github.event.inputs.destroy == 'true' }}
    name: üß® Destruct Infra
    runs-on: ubuntu-latest
    env:
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
    steps:
      - name: Code Checkout
        uses: actions/checkout@v3

      - name: Login in Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Execute Terraform Destroy
        working-directory: infra
        run: |
          terraform init
          terraform destroy -auto-approve
